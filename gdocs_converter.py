# -*- coding: utf-8 -*-
import json
import pickle
import os

import click
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseDownload
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

# If modifying these scopes, delete the file token.pickle.
__BASEDIR__ = os.path.abspath(os.path.dirname(__file__))
SCOPES = ['https://www.googleapis.com/auth/drive.readonly']
MIME_BASE = 'application/vnd.openxmlformats-officedocument'
EXTENSIONS = {
    'gdoc': {
        "mime": MIME_BASE + '.wordprocessingml.document',
        "out_ext": "docx"
    },
    'gsheet': {
        "mime": MIME_BASE + '.spreadsheetml.sheet',
        "out_ext": "xlsx"
    },
    'gslides': {
        "mime": MIME_BASE + '.presentationml.presentation',
        "out_ext": "pptx"
    }
}


@click.group()
def cli():
    pass


@cli.command(short_help='Request a new token to access Google Drive')
@click.argument('token_file',
                default=os.path.join(__BASEDIR__, 'token.pickle'),
                type=click.File('wb'))
@click.option('--credentials', required=True,
              help='Path to the Crednetials file generated by google when '
              'you enable the Drive API https://developers.google.com/'
              'drive/api/v3/quickstart/python#step_1_turn_on_the',
              metavar='FILENAME', show_default=True)
def login(credentials, token_file):
    """Request a new token to access Google Drive

    TOKEN_FILE: Token file path to store the token information.
    The file will be created if it doesn't exist, and replaced
    if it exists. Write permission is needed.
    """
    flow = InstalledAppFlow.from_client_secrets_file(credentials, SCOPES)
    token = flow.run_local_server()
    token.refresh(Request())
    pickle.dump(token, token_file)

    click.echo(f"Token credentials saved to '{token_file.name}'.")


@cli.command(short_help='Convert Google Docs to Microsoft Office')
@click.argument('root_dir_path')
@click.option('--token', 'token_path',
              default=os.path.join(__BASEDIR__, 'token.pickle'),
              metavar="FILENAME",
              help="Path to the pickle-serialized token generated by "
              "the login cmd", show_default=True)
def convert(root_dir_path, token_path):
    """Convert Google Docs to Microsoft Office

    ROOT_DIR_PATH: Path to the root directory where the Google Doc
    files are stored.
    """
    drive_service = create_service(token_path)
    files = all_files(root_dir_path)
    for filedct in files:
        dst_download = path_to_download(filedct)
        if dst_download != -1:
            if dst_download == 0:
                status = "SKIPPED"
            else:
                status = download(drive_service, dst_download, filedct)
            click.echo((filedct['relative'] + ' - ' + status).encode('utf-8'))


def create_service(token_path):
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    # If there are no (valid) credentials available, let the user log in.
    token = None
    if os.path.exists(token_path):
        with open(token_path, 'rb') as f:
            token = pickle.load(f)

    if not token:
        raise Exception("Token doesn't exist. Please login.")

    if token.expired:
        raise Exception("Token expired. Please login again.")

    if not token.valid:
        raise Exception("Token is invalid. Please login again.")

    return build('drive', 'v3', credentials=token)


def all_files(start_dir):
    for root, _, files in os.walk(start_dir):
        rootpath = os.path.abspath(root)
        for filename in files:
            filename_parts = filename.split(".")
            ext, file_no_ext = None, None
            if len(filename_parts) > 1:
                ext = filename_parts[-1].lower()
                file_no_ext = '.'.join(filename_parts[:-1])

            result = {
                "relative": os.path.join(root, filename),
                "fqn": os.path.join(rootpath, filename),
                "rootpath": rootpath,
                "filename": filename,
                "file_without_ext": file_no_ext,
                "ext": ext
            }

            yield result


def path_to_download(filedct):
    """Verify if the file should be downloaded and return where

    If a file should be downloaded, the path where it should be downloaded is
    returned

    :param filedct: A dictionary with the keys:
        ("rootpath", "file_without_ext", "ext")
    :returns:
        -1 if extension doesn't match EXTENSIONS
        0 if file exists,
        FQN string otherwise
    """
    ext = filedct['ext']
    if ext not in EXTENSIONS:
        return -1

    out_filename = os.path.join(
        filedct['rootpath'],
        filedct['file_without_ext'] + '.' + EXTENSIONS[ext]['out_ext'])
    if os.path.exists(out_filename):
        return 0

    return out_filename


def download(drive_service, dst_download, filedct):
    """Download the file for the desired extension

    :param drive_service: An instance of the client for Google Drive Service
    :param dst_download: Destination path of the downloaded file
    :param filedct: A dictionary with the keys:
        ("fqn", "ext")
    """
    extension = EXTENSIONS[filedct['ext']]

    fileid = file_id(filedct['fqn'])
    request = drive_service.files().export_media(
        fileId=fileid, mimeType=extension['mime'])
    delete_file_if_error = not os.path.exists(dst_download)
    try:
        with open(dst_download, 'wb') as dst_file:
            downloader = MediaIoBaseDownload(dst_file, request)
            done = False
            while done is False:
                _, done = downloader.next_chunk()
        return "OK"
    except Exception as e:
        if delete_file_if_error:
            delete_file(dst_download)

        err_msg = str(e).replace("\r", "")
        err_msg = err_msg.replace("\n", " ")
        return f"ERROR ({err_msg})"


def file_id(fqn):
    """Get the Google FileID

    :param fqn: path to a json-like file which contains the key: "doc_id"
    """
    with open(fqn) as json_file:
        result = json.load(json_file)
        return result['doc_id']


def delete_file(dst_download):
    if os.path.exists(dst_download):
        os.remove(dst_download)


def main():
    try:
        cli()
    except Exception as e:
        click.echo(e, err=True)


if __name__ == '__main__':
    main()
